---
/**
 * Z80 Assembler in Typescript
 *
 * File:        z80.peg
 * Description: PEG grammar of the Z80 assembly language
 * Author:		Sebastien Andrivet
 * License:		GPLv3
 * Copyrights: 	Copyright (C) 2023 Sebastien Andrivet
 */
import {
    r_bits,
    dd_bits,
    qq_bits,
    ss_bits,
    pp_bits,
    rr_bits,
    cc_bits,
    jj_bits,
    p_bits,
    imode,
    ixy_prefix,
    ixy_suffix
} from "./LowLevel";

import {
  parseNumber,
  parseChar,
  parseSimpleEscape,
  parseOctalEscape,
  parseHexadecimalEscape} from './Parse';
import {LinesInfo, Address} from '../types/Types';

import {
    EvalFunc,
    AstElements,
    binaryOperation,
    binaryOperations,
    unaryOperation,
    unaryOperations,
    operatorOr,
    operatorXor,
    operatorAnd,
    operatorLeftShift,
    operatorRightShift,
    operatorAdd,
    operatorSub,
    operatorMul,
    operatorDiv,
    operatorModulo,
    operatorPlus,
    operatorNeg,
    operatorInvert,
    operatorIdentity,
    value16LE,
    value8,
    index,
    index_1,
    jrOffset,
    jrRelativeOffset,
    dataBytes,
    dataWords,
    dataBlock,
    labelValue,
    value
} from '../compiler/Ast';

import {setOutputName, setDevice, includeFile} from '../compiler/Compiler';
---

// Start (top level symbol) of the grammar
start := lines=Lines $ // Les followed by the end of the code

// Names of the registers for the different opcodes (the names are from the Z80 CPU User Manual)
r := 'a' | 'b' | 'c' | 'd' | 'e' | 'h' | 'l'
dd := 'bc' | 'de' | 'hl' | 'sp'
ss := dd
qq := 'bc' | 'de' | 'hl' | 'af'
pp := 'bc' | 'de' | 'ix' | 'sp'
rr := 'bc' | 'de' | 'iy' | 'sp'

// With undocumented registers
rx := 'a' | 'b' | 'c' | 'd' | 'e' | 'ixh' | 'ixl' | 'xh' | 'xl'
ry := 'a' | 'b' | 'c' | 'd' | 'e' | 'iyh' | 'iyl' | 'yh' | 'yl'
ixy8 := 'ixh' | 'ixl' | 'iyh' | 'iyl' | 'xh' | 'xl' | 'yh' | 'yl'

// 8-bit values
// Note: binary is before hexadecimal because 0b is ambiguous
n :=
    pos=@ binary=binary               .value = number { return parseNumber(pos, binary.raw, 2, 1); } |
    pos=@ hexadecimal=hexadecimal     .value = number { return parseNumber(pos, hexadecimal.raw, 16, 1); } |
    pos=@ octal=octal                 .value = number { return parseNumber(pos, octal.raw, 8, 1); } |
    pos=@ decimal=decimal             .value = number { return parseNumber(pos, decimal.raw, 10, 1); }

// 16-bit values
// Note: binary is before hexadecimal because 0b is ambiguous
nn :=
    pos=@ binary=binary               .value = number { return parseNumber(pos, binary.raw, 2, 2); } |
    pos=@ hexadecimal=hexadecimal     .value = number { return parseNumber(pos, hexadecimal.raw, 16, 2); } |
    pos=@ octal=octal                 .value = number { return parseNumber(pos, octal.raw, 8, 2); } |
    pos=@ decimal=decimal             .value = number { return parseNumber(pos, decimal.raw, 10, 2); }

// A decimal unsigned value with the different allowed syntaxes
decimal :=
    raw='[0-9]+' 'd'?

// A binary value with the different allowed syntaxes
binary :=
    {'0b' | '%'} raw='[0-1]+' |
    raw='[0-1]+' 'b'

// An octal value with the different allowed syntaxes
octal :=
    {'0q' | '0o' | '@'} raw='[0-7]+' |
    raw='[0-7]+' {'q' | 'o'}

// An hexadecimal value with the different allowed syntaxes
// To avoid ambiguity, hexadecimal values are not allowed to be followed by an alphanumerical character
hexadecimal :=
    {'0x' | '\$' | '#'} raw='[0-9a-f]+' |
    raw='[0-9a-f]+' 'h' !'[0-9a-z]'

// Different names used in the Z80 CPU User Manual for 8-bit values
d := n
e := n
p := n

// A bit value
b := raw='[0-7]'    .value = number { return parseInt(raw); }

// Conditional flags for jumps
cc := 'nz' | 'z' | 'nc' | 'c' | 'po' | 'pe' | 'p' | 'm' | 's'
// Conditional flags for djnz
jj := 'c'  | 'nc' | 'z' | 'nz'

__   := '[ \t]+'                // Mandatory space
_    := '[ \t]*'                // Optional space
eos := '[ \t]*(;|\r\n|\n|//)'   // End of statement
eol := '\r\n|\n'                // End of line

// Lines is a list of lines (can be empty)
Lines :=
    Line*

// A line is either an equality or a statement
Line :=
  LineEqual | LineStatement

// An equality is a label (mandatory) followed by an equality directive, an optional comment and an end of line.
LineEqual :=
  label=LabelDeclaration _ equal=EqualDirective _ comment=Comment? eol

// A line with a statement is an optional label, followed by a statement, an optional comment and an end of line.
LineStatement :=
  label=LabelDeclaration? _ statement=Statement? _ comment=Comment? eol

// A statement is either an include, an instruction or a directive
Statement :=
    inc=IncludeDirective
    .info = LinesInfo { return inc.info; } |

    ins=Instruction
    .elements = AstElements { return ins.elements; } |

    dir=Directive
    .elements = AstElements { return dir.elements; }
    .address = Address { return dir.address; }

// An equality directive is 'equ' (or an alias) followed by an expression
EqualDirective :=
    '\.?equ|eq|=' __ e=Expression

// A directive is either a data directive, an origin directive, an output directive or a device directive
Directive :=
    data=DataDirective
    .elements = AstElements { return data.elements; }
    .address = Address { return null; } |

    origin=OriginDirective
    .elements = AstElements { return []; }
    .address = Address { return origin.address.value; } |

    directive=OutputDirective
    .elements = AstElements { return []; }
    .address = Address { return null; } |

    directive=DeviceDirective
    .elements = AstElements { return []; }
    .address = Address { return null; } |

    directive=EndDirective
    .elements = AstElements { return []; }
    .address = Address { return null; }

// Names not allowed for a label
ForbiddenNames :=
    '\.?block|\.?equ|\.?org|\.?include|\.?output|\.?device|\.?end|\.?byte' |
    'call|cpdr|cpir|defb|defm|defs|defw|djnz|eq|halt|indr|inir|lddr|ldir|otdr|otir|outd|outi|push|reti|retn|rlca|rrca|\.?word' |
    'adc|add|and|bit|ccf|cpd|cpi|cpl|daa|dec|exx|inc|ind|ini|ldd|ldi|neg|nop|org|out|pop|res|ret|rla' |
    'rlc|rld|rra|rrc|rrd|rst|sbc|scf|set|sla|sll|sli|sra|srl|sub|xor' |
    'cp|db|di|dm|ds|dw|ei|eq|ex|im|in|jp|jr|ld|or|rl|rr|ldi|ldd'

// A forbidden label is a name not allowed for a label followed by a space, a tabulation, the character ':' or an end of line.
ForbiddenLabel :=
    ForbiddenNames '[ \t:\r\n]'

// A label can't have a forbidden name. It is a name or the special pseudo label $ (PC).
Label :=
    !ForbiddenLabel pos=@ name='[a-z_\.][a-z0-9_!\?#@\.\$]*|\$'

// A label declaration can't have a forbidden name. It is a name optionally followed by a ':' character.
LabelDeclaration :=
    !ForbiddenLabel pos=@ name='[a-z_\.][a-z0-9_!\?#@\.\$]*' '\:'?


// An expression is a bitwise OR expression
Expression :=
    e1=BitwiseOrExpression
    .eval = EvalFunc { return e1.eval; }

// Precedences: unary, multiplicative, additive, shift, and, xor, or
// Associativity: left to right

// A bitwise OR expression is a list of bitwise OR expressions (eventually empty) followed by a bitwise XOR expression
BitwiseOrExpression :=
    left={e=BitwiseOrExpression _ '\|'}? _ right=BitwiseXOrExpression
    .eval = EvalFunc { return binaryOperation(left, right, operatorOr); }

// A bitwise XOR expression is a list of bitwise XOR expressions (eventually empty) followed by a bitwise AND expression
BitwiseXOrExpression :=
    left={e=BitwiseXOrExpression _ '\^'}? _ right=BitwiseAndExpression
    .eval = EvalFunc { return binaryOperation(left, right, operatorXor); }

// A bitwise AND expression is a list of bitwise AND expressions (eventually empty) followed by a bitwise Shift expression
BitwiseAndExpression :=
    left={e=BitwiseAndExpression _ '\&'}? _ right=ShiftExpression
    .eval = EvalFunc { return binaryOperation(left, right, operatorAnd); }

// A bitwise Shift expression is a list of bitwise Shift expressions (eventually empty) followed by an Additive expression
ShiftExpression :=
    left={e=ShiftExpression _ op={'<<' | '>>'}}? _ right=AdditiveExpression
    .eval = EvalFunc { return binaryOperations(left, right, {'<<': operatorLeftShift, '>>': operatorRightShift}); }

// An Additive expression is a list of Additive expressions (eventually empty) followed by a Multiplicative expression
AdditiveExpression :=
    left={e=AdditiveExpression _ op={'\+' | '\-'}}? _ right=MultiplicativeExpression
    .eval = EvalFunc { return binaryOperations(left, right, {'+': operatorAdd, '-': operatorSub}); }

// A Multiplicative expression is a list of Multiplicative expressions (eventually empty) followed by an Unary expression
MultiplicativeExpression :=
    left={e=MultiplicativeExpression _ op={'\*' | '%' | '/'}}? _ right=UnaryExpression
    .eval = EvalFunc { return binaryOperations(left, right, {'*': operatorMul, '/': operatorDiv, '%': operatorModulo} ); }

// An Unary expression is an optional unary operator followed by a Primary expression
UnaryExpression :=
    op={'~' | '\+' | '\-'} _ e=PrimaryExpression
    .eval = EvalFunc { return unaryOperations(e, op, {'~': operatorInvert, '+': operatorPlus, '-': operatorNeg} ); } |

    e=PrimaryExpression
    .eval = EvalFunc { return unaryOperation(e, operatorIdentity); }

// A Primary expression is a either a number, a label or an expression enclosed in parenthesis
PrimaryExpression :=
    nn=nn
    .eval = EvalFunc { return value(nn.value); } |

    pos=@ label=Label
    .eval = EvalFunc { return labelValue(pos, label.name); } |

    '\(' e=BitwiseOrExpression '\)'
    .eval = EvalFunc { return unaryOperation(e, operatorIdentity); }

// A 8-bit register is the name of a 8-bit register but can't be followed by characters such as alphanumerical
// or symbols. This is to distinguish registers from labels
Reg8 :=
    reg=r &'[^a-z0-9_!\?#@\.]'

Reg16 :=
    reg=qq &'[^a-z0-9_!\?#@\.]'

// With undocumented registers
RegX8 :=
    reg=rx &'[^a-z0-9_!\?#@\.]'

RegY8 :=
    reg=ry &'[^a-z0-9_!\?#@\.]'

// IX register with an (optional) offset
IX :=
  'ix' offset={ _ s={'\+' | '\-'} _ pos=@ d=Expression }?

// IY register with an (optional) offset
IY :=
  'iy' offset={ _ s={'\+' | '\-'} _ pos=@ d=Expression }?

// An instruction
Instruction :=
    FakeLoad16Instruction |
    Load8Instruction |
    Load16Instruction |
    ExchangeInstruction |
    BlockInstruction |
    ArithmeticLogic8Instruction |
    IncrementDecrement8Instruction |
    GeneralPurposeArithmeticInstruction |
    ArithmeticLogic16Instruction |
    FakeArithmetic16Instruction |
    FakeLoadIncrement16Instruction |
    FakeLoadIncrement8Instruction |
    FakeLoadDecrement8Instruction |
    RotateShiftInstruction |
    FakeRotateShiftInstruction16 |
    BitManipulationInstruction |
    JumpInstruction |
    CallInstruction |
    ReturnInstruction |
    InputInstruction |
    OutputInstruction |
    CpuControlGroupInstruction

// 8-bit Load
Load8Instruction :=
    // LD r, r'
    'ld' __ r0=Reg8 _ ',' _ r1=Reg8 &eos
    .elements = AstElements { return [0b01000000 | r_bits(r0.reg, 3) | r_bits(r1.reg)]; } |

    // Undocumented LD r, IXh
    'ld' __ r0=Reg8 _ ',' _ 'ixh' &eos
    .elements = AstElements { return [0xDD, 0b01000000 | r_bits(r0.reg, 3) | 0b100]; } |

    // Undocumented LD r, IXl
    'ld' __ r0=Reg8 _ ',' _ 'ixl' &eos
    .elements = AstElements { return [0xDD, 0b01000000 | r_bits(r0.reg, 3) | 0b101]; } |

    // Undocumented LD r, IYh
    'ld' __ r0=Reg8 _ ',' _ 'iyh' &eos
    .elements = AstElements { return [0xFD, 0b01000000 | r_bits(r0.reg, 3) | 0b100]; } |

    // Undocumented LD r, IYl
    'ld' __ r0=Reg8 _ ',' _ 'iyl' &eos
    .elements = AstElements { return [0xFD, 0b01000000 | r_bits(r0.reg, 3) | 0b101]; } |

    // Undocumented LD IXh, rx
    'ld' __ 'ixh' _ ',' _ r1=RegX8 &eos
    .elements = AstElements { return [0xDD, 0b01000000 | 0b100000 | r_bits(r1.reg)]; } |

    // Undocumented LD IXl, rx
    'ld' __ 'ixl' _ ',' _ r1=RegX8 &eos
    .elements = AstElements { return [0xDD, 0b01000000 | 0b101000 | r_bits(r1.reg)]; } |

    // Undocumented LD IYh, ry
    'ld' __ 'iyh' _ ',' _ r1=RegY8 &eos
    .elements = AstElements { return [0xFD, 0b01000000 | 0b100000 | r_bits(r1.reg)]; } |

    // Undocumented LD IYl, ry
    'ld' __ 'iyl' _ ',' _ r1=RegY8 &eos
    .elements = AstElements { return [0xFD, 0b01000000 | 0b101000 | r_bits(r1.reg)]; } |

    // Undocumented LD IXh, n
    'ld' __ 'ixh' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xDD, 0x26, value8(pos, n)]; } |

    // Undocumented LD IXl, n
    'ld' __ 'ixl' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xDD, 0x2E, value8(pos, n)]; } |

    // Undocumented LD IYh, n
    'ld' __ 'iyh' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xFD, 0x26, value8(pos, n)]; } |

    // Undocumented LD IYl, n
    'ld' __ 'iyl' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xFD, 0x2E, value8(pos, n)]; } |

    // LD r, (HL)
    'ld' __ r=r _ ',' _ '\(' 'hl' '\)' &eos
    .elements = AstElements { return [0b01000110 | r_bits(r, 3)]; } |

    // LD r, (IX+d)
    'ld' __ r=r _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0b01000110 | r_bits(r, 3), index(i.offset)]; } |

    // LD r, (IY+d)
    'ld' __ r=r _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0b01000110 | r_bits(r, 3), index(i.offset)]; } |

    // LD (HL), r
    'ld' __ '\(' _ 'hl' _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0b01110000 | r_bits(r)]; } |

    // LD (IX+d), r
    'ld' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0b01110000 | r_bits(r), index(i.offset)]; } |

    // LD (IY+d), r
    'ld' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0b01110000 | r_bits(r), index(i.offset)]; } |

    // LD (HL), n
    'ld' __ '\(' 'hl' '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0x36, value8(pos, n)]; } |

    // LD (IX+d), n
    'ld' __ '\(' _ i=IX _ '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xDD, 0x36, index(i.offset), value8(pos, n)]; } |

    // LD (IY+d), n
    'ld' __ '\(' _ i=IY _ '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xFD, 0x36, index(i.offset), value8(pos, n)]; } |

    // LD A, (BC)
    'ld' __ 'a' _ ',' _ '\(' _ 'bc' _ '\)' &eos
    .elements = AstElements { return [0x0A]; } |

    // LD A, (DE)
    'ld' __ 'a' _ ',' _ '\(' _ 'de' _ '\)' &eos
    .elements = AstElements { return [0x1A]; } |

    // LD A, (nn)
    'ld' __ 'a' _ ',' _ '\(' _ pos=@ ee=Expression _ '\)' &eos
    .elements = AstElements { return [0x3A, value16LE(pos, ee)]; } |

    // LD (BC), A
    'ld' __ '\(' _ 'bc' _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0x02]; } |

    // LD (DE), A
    'ld' __ '\(' _ 'de' _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0x12]; } |

    // LD (nn), A
    'ld' __ '\(' _ pos=@ ee=Expression _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0x32, value16LE(pos, ee)]; } |

    // LD A, I
    'ld' __ 'a' _ ',' _ 'i' &eos
    .elements = AstElements { return [0xED, 0x57]; } |

    // LD A, R
    'ld' __ 'a' _ ',' _ 'r' &eos
    .elements = AstElements { return [0xED, 0x5F]; } |

    // LD I, A
    'ld' __ 'i' _ ',' _ 'a' &eos
    .elements = AstElements { return [0xED, 0x47]; } |

    // LD R, A
    'ld' __ 'r' _ ',' _ 'a' &eos
    .elements = AstElements { return [0xED, 0x4F]; } |

    // Have to be after the others to avoid ambiguity on n=Expression
    // LD r, n
    // Have to be before LD r,r' because it is ambiguous
    'ld' __ r=Reg8 _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0b00000110 | r_bits(r.reg, 3), value8(pos, n)]; }

// 16-bit Load
Load16Instruction :=
    // LD IX, (nn)
    'ld' __ 'ix' _ ',' _ '\(' _ pos=@ ee=Expression _ '\)' &eos
    .elements = AstElements { return [0xDD, 0x2A, value16LE(pos, ee)]; } |

    // LD IY, (nn)
    'ld' __ 'iy' _ ',' _ '\(' _ pos=@ ee=Expression _ '\)' &eos
    .elements = AstElements { return [0xFD, 0x2A, value16LE(pos, ee)]; } |

    // LD IX, nn
    'ld' __ 'ix' _ ',' _ pos=@ ee=Expression &eos
    .elements = AstElements { return [0xDD, 0x21, value16LE(pos, ee)]; } |

    // LD IY, nn
    'ld' __ 'iy' _ ',' _ pos=@ ee=Expression &eos
    .elements = AstElements { return [0xFD, 0x21, value16LE(pos, ee)]; } |

    // LD HL, (nn)
    'ld' __ 'hl' _ ',' _ '\(' _ pos=@ ee=Expression _ '\)' &eos
    .elements = AstElements { return [0x2A, value16LE(pos, ee)]; } |

    // LD dd, (nn)
    'ld' __ dd=dd _ ',' _ '\(' _ pos=@ ee=Expression _ '\)' &eos
    .elements = AstElements { return [0xED, 0b01001011 | dd_bits(dd, 4), value16LE(pos, ee)]; } |

    // LD (nn), HL
    'ld' __ '\(' _ pos=@ ee=Expression _ '\)' _ ',' _ 'hl' &eos
    .elements = AstElements { return [0x22, value16LE(pos, ee)]; } |

    // LD (nn), dd
    'ld' __ '\(' _ pos=@ ee=Expression _ '\)' _ ',' _ dd=dd &eos
    .elements = AstElements { return [0xED, 0b01000011 | dd_bits(dd, 4), value16LE(pos, ee)]; } |

    // LD (nn), IX
    'ld' __ '\(' _ pos=@ ee=Expression _ '\)' _ ',' _ 'ix' &eos
    .elements = AstElements { return [0xDD, 0x22, value16LE(pos, ee)]; } |

    // LD (nn), IY
    'ld' __ '\(' _ pos=@ ee=Expression _ '\)' _ ',' _ 'iy' &eos
    .elements = AstElements { return [0xFD, 0x22, value16LE(pos, ee)]; } |

    // LD SP, HL
    'ld' __ 'sp' _ ',' _ 'hl' &eos
    .elements = AstElements { return [0xF9]; } |

    // LD SP, IX
    'ld' __ 'sp' _ ',' _ 'ix' &eos
    .elements = AstElements { return [0xDD, 0xF9]; } |

    // LD SP, IY
    'ld' __ 'sp' _ ',' _ 'iy' &eos
    .elements = AstElements { return [0xFD, 0xF9]; } |

    // Have to be after the other LD instructions
    // LD dd, nn
    'ld' __ dd=dd _ ',' _ pos=@ ee=Expression &eos
    .elements = AstElements { return [0b00000001 | dd_bits(dd, 4), value16LE(pos, ee)]; } |

    // PUSH qq
    'push' __ qq=qq &eos
    .elements = AstElements { return [0b11000101 | qq_bits(qq, 4)]; } |

    // PUSH IX
    'push' __ 'ix' &eos
    .elements = AstElements { return [0xDD, 0xE5]; } |

    // PUSH IY
    'push' __ 'iy' &eos
    .elements = AstElements { return [0xFD, 0xE5]; } |

    // POP qq
    'pop' __ qq=qq &eos
    .elements = AstElements { return [0b11000001 | qq_bits(qq, 4)]; } |

    // POP IX
    'pop' __ 'ix' &eos
    .elements = AstElements { return [0xDD, 0xE1]; } |

    // POP IY
    'pop' __ 'iy' &eos
    .elements = AstElements { return [0xFD, 0xE1]; }

FakeLoad16Instruction :=
    // LD qq, qq'
    'ld' __ r0=Reg16 _ ',' _ r1=Reg16 &eos
    .elements = AstElements { return [
      0b01000000 | r_bits(r0.reg[0], 3) | r_bits(r1.reg[0]),
      0b01000000 | r_bits(r0.reg[1], 3) | r_bits(r1.reg[1]),
    ]; } |

    // LD qq, ix
    'ld' __ r0=Reg16 _ ',' _ 'ix' &eos
    .elements = AstElements { return [
      0xDD, 0b01000000 | r_bits(r0.reg[0], 3) | 0b100,
      0xDD, 0b01000000 | r_bits(r0.reg[1], 3) | 0b101,
    ]; } |

    // LD qq, iy
    'ld' __ r0=Reg16 _ ',' _ 'iy' &eos
    .elements = AstElements { return [
      0xFD, 0b01000000 | r_bits(r0.reg[0], 3) | 0b100,
      0xFD, 0b01000000 | r_bits(r0.reg[1], 3) | 0b101,
    ]; } |

    // LD qq, (HL) = LD q, (HL), INC HL, LD q, (HL), DEC HL
    'ld' __ qq=qq _ ',' _ '\(' 'hl' '\)' &eos
    .elements = AstElements { return [
      0b01000110 | r_bits(qq[1], 3),
      0x23,
      0b01000110 | r_bits(qq[0], 3),
      0x2B
    ]; } |

    // LD qq, (IX+d) = LD q, (IX+d), LD q, (IX+d+1)
    'ld' __ qq=qq _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [
      0xDD, 0b01000110 | r_bits(qq[1], 3), index(i.offset),
      0xDD, 0b01000110 | r_bits(qq[0], 3), index_1(i.offset)
    ]; } |

    // LD qq, (IY+d) = LD q, (IY+d), LD q, (IY+d+1)
    'ld' __ qq=qq _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [
      0xFD, 0b01000110 | r_bits(qq[1], 3), index(i.offset),
      0xFD, 0b01000110 | r_bits(qq[0], 3), index_1(i.offset)
    ]; } |

    // LD IX, qq = LD IXh, q, LD IXl, q
    'ld' __ 'ix' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0xDD, 0b01000000 | 0b100000 | r_bits(qq[0]),
      0xDD, 0b01000000 | 0b101000 | r_bits(qq[1])
    ]; } |

    // LD IY, qq = LD IYh, q, LD IYl, q
    'ld' __ 'iy' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0xFD, 0b01000000 | 0b100000 | r_bits(qq[0]),
      0xFD, 0b01000000 | 0b101000 | r_bits(qq[1])
    ]; } |

    // LD IX, IY = PUSH IY, POP IX
    'ld' __ 'ix' _ ',' _ 'iy' &eos
    .elements = AstElements { return [
      0xFD, 0xE5,
      0xDD, 0xE1
    ]; } |

    // LD IY, IX = PUSH IX, POP IY
    'ld' __ 'iy' _ ',' _ 'ix' &eos
    .elements = AstElements { return [
      0xDD, 0xE5,
      0xFD, 0xE1
    ]; } |

    // LD (HL), qq = LD (HL), q1, INC HL, LD (HL), q0, DEC HL
    'ld' __ '\(' _ 'hl' _ '\)' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0b01110000 | r_bits(qq[1]),
      0x23,
      0b01110000 | r_bits(qq[0]),
      0x2B
    ]; } |

    // LD (IX+d), qq = LD (IX+d), q1, LD (IX+d+1), q0
    'ld' __ '\(' _ i=IX _ '\)' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0xDD, 0b01110000 | r_bits(qq[1]), index(i.offset),
      0xDD, 0b01110000 | r_bits(qq[0]), index_1(i.offset)
    ]; } |

    // LD (IY+d), qq = LD (IY+d), q1, LD (IY+d+1), q0
    'ld' __ '\(' _ i=IY _ '\)' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0xFD, 0b01110000 | r_bits(qq[1]), index(i.offset),
      0xFD, 0b01110000 | r_bits(qq[0]), index_1(i.offset)
    ]; }


// Exchange
ExchangeInstruction :=
    // EX DE, HL
    'ex' __ 'de' _ ',' _ 'hl' &eos
    .elements = AstElements { return [0xEB]; } |

    // EX AF, AF'
    'ex' __ 'af' _ ',' _ 'af\'' &eos
    .elements = AstElements { return [0x08]; } |

    // EXX
    'exx' &eos
    .elements = AstElements { return [0xD9]; } |

    // EX (SP), HL
    'ex' __ '\(' 'sp' '\)' _ ',' _ 'hl' &eos
    .elements = AstElements { return [0xE3]; } |

    // EX (SP), IX
    'ex' __ '\(' 'sp' '\)' _ ',' _ 'ix' &eos
    .elements = AstElements { return [0xDD, 0xE3]; } |

    // EX (SP), IY
    'ex' __ '\(' 'sp' '\)' _ ',' _ 'iy' &eos
    .elements = AstElements { return [0xFD, 0xE3]; }

// Block Transfer and Search
BlockInstruction :=
    // Have to be before ldi
    // LDIR
    'ldir' &eos
    .elements = AstElements { return [0xED, 0xB0]; } |

    // LDI
    'ldi' &eos
    .elements = AstElements { return [0xED, 0xA0]; } |

    // LDDR
    'lddr' &eos
    .elements = AstElements { return [0xED, 0xB8]; } |

    // LDD
    'ldd' &eos
    .elements = AstElements { return [0xED, 0xA8]; } |

    // CPIR
    'cpir' &eos
    .elements = AstElements { return [0xED, 0xB1]; } |

    // CPI
    'cpi' &eos
    .elements = AstElements { return [0xED, 0xA1]; } |

    // CPDR
    'cpdr' &eos
    .elements = AstElements { return [0xED, 0xB9]; } |

    // CPD
    'cpd' &eos
    .elements = AstElements { return [0xED, 0xA9]; }

// 8-bit Arithmetic
ArithmeticLogic8Instruction :=
    // ADD A, (HL)
    'add' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0x86]; } |

    // ADD A, (IX+d)
    'add' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0x86, index(i.offset)]; } |

    // ADD A, (IY+d)
    'add' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0x86, index(i.offset)]; } |

    // ADD A, r
    'add' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10000000 | r_bits(r)]; } |

    // Undocumented ADD A, IXh
    'add' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0x84)]; } |

    // ADD A, n
    'add' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xC6, value8(pos, n)]; } |

    // ADC A, (HL)
    'adc' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0x8E]; } |

    // ADC (IX+d)
    'adc' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0x8E, index(i.offset)]; } |

    // ADC (IY+d)
    'adc' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0x8E, index(i.offset)]; } |

    // ADC A, r
    'adc' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10001000 | r_bits(r)]; } |

    // Undocumented ADC A, IXh
    'adc' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0x8C)]; } |

    // ADC A, n
    'adc' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xCE, value8(pos, n)]; } |

    // SUB A, (HL)
    'sub' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0x96]; } |

    // SUB (IX+d)
    'sub' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0x96, index(i.offset)]; } |

    // SUB (IY+d)
    'sub' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0x96, index(i.offset)]; } |

    // SUB A, r
    'sub' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10010000 | r_bits(r)]; } |

    // Undocumented SUB A, IXh
    'sub' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0x94)]; } |

    // SUB A, n
    'sub' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xD6, value8(pos, n)]; } |

    // SBC A, (HL)
    'sbc' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0x9E]; } |

    // SBC (IX+d)
    'sbc' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0x9E, index(i.offset)]; } |

    // SBC (IY+d)
    'sbc' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0x9E, index(i.offset)]; } |

    // SBC A, r
    'sbc' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10011000 | r_bits(r)]; } |

    // Undocumented SBC A, IXh
    'sbc' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0x9C)]; } |

    // SBC A, n
    'sbc' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xDE, value8(pos, n)]; } |

    // AND A, (HL)
    'and' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0xA6]; } |

    // AND (IX+d)
    'and' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xA6, index(i.offset)]; } |

    // AND (IY+d)
    'and' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xA6, index(i.offset)]; } |

    // AND A, r
    'and' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10100000 | r_bits(r)]; } |

    // Undocumented AND A, IXh
    'and' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0xA4)]; } |

    // AND A, n
    'and' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xE6, value8(pos, n)]; } |

    // OR A, (HL)
    'or' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0xB6]; } |

    // OR (IX+d)
    'or' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xB6, index(i.offset)]; } |

    // OR (IY+d)
    'or' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xB6, index(i.offset)]; } |

    // OR A, r
    'or' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10110000 | r_bits(r)]; } |

    // Undocumented OR A, IXh
    'or' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0xB4)]; } |

    // OR A, n
    'or' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xF6, value8(pos, n)]; } |

    // XOR A, (HL)
    'xor' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0xAE]; } |

    // XOR (IX+d)
    'xor' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xAE, index(i.offset)]; } |

    // XOR (IY+d)
    'xor' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xAE, index(i.offset)]; } |

    // XOR A, r
    'xor' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10101000 | r_bits(r)]; } |

    // Undocumented XOR A, IXh
    'xor' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0xAC)]; } |

    // XOR A, n
    'xor' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xEE, value8(pos, n)]; } |

    // CP A, (HL)
    'cp' __ {'a' _ ',' _}? '\(' _ 'hl'_ '\)' &eos
    .elements = AstElements { return [0xBE]; } |

    // CP (IX+d)
    'cp' __ {'a' _ ',' _}? '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xBE, index(i.offset)]; } |

    // CP (IY+d)
    'cp' __ {'a' _ ',' _}? '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xBE, index(i.offset)]; } |

    // CP A, r
    'cp' __ {'a' _ ',' _}? r=r &eos
    .elements = AstElements { return [0b10111000 | r_bits(r)]; } |

    // Undocumented CP A, IXh
    'cp' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0xBC)]; } |

    // CP A, n
    'cp' __ {'a' _ ',' _}? pos=@ n=Expression &eos
    .elements = AstElements { return [0xFE, value8(pos, n)]; }


// 8-bit Increment and Decrement
IncrementDecrement8Instruction :=
    // INC r
    'inc' __ r=r &eos
    .elements = AstElements { return [0b00000100 | r_bits(r, 3)]; } |

    // Undocumented INC IXh
    'inc' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0x24, 8)]; } |

    // INC (HL)
    'inc' __ '\(' _ 'hl' _ '\)' &eos
    .elements = AstElements { return [0x34]; } |

    // INC (IX+d)
    'inc' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0x34, index(i.offset)]; } |

    // INC (IY+d)
    'inc' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0x34, index(i.offset)]; } |

    // DEC r
    'dec' __ r=r &eos
    .elements = AstElements { return [0b00000101 | r_bits(r, 3)]; } |

    // Undocumented DEC IXh
    'dec' __ {'a' _ ',' _}? r=ixy8 &eos
    .elements = AstElements { return [ixy_prefix(r), ixy_suffix(r, 0x25, 8)]; } |

    // DEC (HL)
    'dec' __ '\(' _ 'hl' _ '\)' &eos
    .elements = AstElements { return [0x35]; } |

    // DEC (IX+d)
    'dec' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0x35, index(i.offset)]; } |

    // DEC (IY+d)
    'dec' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0x35, index(i.offset)]; }

// General Purpose Arithmetic Instructions
GeneralPurposeArithmeticInstruction :=
    // DAA
    'daa' &eos
    .elements = AstElements { return [0x27]; } |

    // CPL
    'cpl' &eos
    .elements = AstElements { return [0x2F]; } |

    // NEG
    'neg' &eos
    .elements = AstElements { return [0xED, 0x44]; } |

    // CCF
    'ccf' &eos
    .elements = AstElements { return [0x3F]; } |

    // SCF
    'scf' &eos
    .elements = AstElements { return [0x37]; }

// CPU Control Group Instructions
CpuControlGroupInstruction :=
    // NOP
    'nop' &eos
    .elements = AstElements { return [0x00]; } |

    // HALT
    'halt' &eos
    .elements = AstElements { return [0x76]; } |

    // DI
    'di' &eos
    .elements = AstElements { return [0xF3]; } |

    // EI
    'ei' &eos
    .elements = AstElements { return [0xFB]; } |

    // IM 0, IM 1, IM 2
    'im' __ m='[012]' &eos
    .elements = AstElements { return [0xED, imode(m)]; }

// 16-bit Arithmetic
ArithmeticLogic16Instruction :=
    // ADD HL, ss
    'add' __ 'hl' _ ',' _ ss=ss &eos
    .elements = AstElements { return [0b00001001 | ss_bits(ss, 4)]; } |

    // ADC HL, ss
    'adc' __ 'hl' _ ',' _ ss=ss &eos
    .elements = AstElements { return [0xED, 0b01001010 | ss_bits(ss, 4)]; } |

    // SBC HL, ss
    'sbc' __ 'hl' _ ',' _ ss=ss &eos
    .elements = AstElements { return [0xED, 0b01000010 | ss_bits(ss, 4)]; } |

    // ADD IX, pp
    'add' __ 'ix' _ ',' _ pp=pp &eos
    .elements = AstElements { return [0xDD, 0b00001001 | pp_bits(pp, 4)]; } |

    // ADD IY, pp
    'add' __ 'iy' _ ',' _ rr=rr &eos
    .elements = AstElements { return [0xFD, 0b00001001 | rr_bits(rr, 4)]; } |

    // INC ss
    'inc' __ ss=ss &eos
    .elements = AstElements { return [0b00000011 | ss_bits(ss, 4)]; } |

    // INC IX
    'inc' __ 'ix' &eos
    .elements = AstElements { return [0xDD, 0x23]; } |

    // INC IY
    'inc' __ 'iy' &eos
    .elements = AstElements { return [0xFD, 0x23]; } |

    // DEC ss
    'dec' __ ss=ss &eos
    .elements = AstElements { return [0b00001011 | ss_bits(ss, 4)]; } |

    // DEC IX
    'dec' __ 'ix' &eos
    .elements = AstElements { return [0xDD, 0x2B]; } |

    // DEC IY
    'dec' __ 'iy' &eos
    .elements = AstElements { return [0xFD, 0x2B]; }

// Fake 16-bit Arithmetic
FakeArithmetic16Instruction :=
    // ADC DE, ss = EX DE, HL, ADC HL, ss : EX DE, HL
    'adc' __ 'de' _ ',' _ ss=ss &eos
    .elements = AstElements { return [
      0xEB,
      0xED, 0b01001010 | ss_bits(ss, 4),
      0xEB
    ]; } |

    // ADD DE, ss = EX DE, HL, ADD HL, ss : EX DE, HL
    'add' __ 'de' _ ',' _ ss=ss &eos
    .elements = AstElements { return [
      0xEB,
      0b00001001 | ss_bits(ss, 4),
      0xEB
    ]; } |

    // SBC DE, ss = EX DE, HL, SBC HL, ss : EX DE, HL
    'sbc' __ 'de' _ ',' _ ss=ss &eos
    .elements = AstElements { return [
      0xEB,
      0xED, 0b01000010 | ss_bits(ss, 4),
      0xEB
    ]; } |

    // SUB HL, ss = OR A, SBC HL, ss
    'sub' __ 'hl' _ ',' _ ss=ss &eos
    .elements = AstElements { return [
      0xB7,
      0xED, 0b01000010 | ss_bits(ss, 4)
    ]; } |

    // SUB DE, ss = EX DE, HL, SUB HL, ss : EX DE, HL
    'sub' __ 'de' _ ',' _ ss=ss &eos
    .elements = AstElements { return [
      0xEB,
      0xB7,
      0xED, 0b01000010 | ss_bits(ss, 4),
      0xEB
    ]; }

FakeLoadIncrement16Instruction :=
    // LDI qq, (HL) = LD q, (HL), INC HL, LD q, (HL), INC HL
    'ldi' __ qq=qq _ ',' _ '\(' 'hl' '\)' &eos
    .elements = AstElements { return [
      0b01000110 | r_bits(qq[1], 3),
      0x23,
      0b01000110 | r_bits(qq[0], 3),
      0x23
    ]; } |

    // LDI qq, (IX+d) = LD q, (IX+d), INC IX, LD q, (IX+d), INC IX
    'ldi' __ qq=qq _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [
      0xDD, 0b01000110 | r_bits(qq[1], 3), index(i.offset),
      0xDD, 0x23,
      0xDD, 0b01000110 | r_bits(qq[0], 3), index(i.offset),
      0xDD, 0x23
    ]; } |

    // LDI qq, (IY+d) = LD q, (IY+d), INC IY, LD q, (IY+d), INC IY
    'ldi' __ qq=qq _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [
      0xFD, 0b01000110 | r_bits(qq[1], 3), index(i.offset),
      0xFD, 0x23,
      0xFD, 0b01000110 | r_bits(qq[0], 3), index(i.offset),
      0xFD, 0x23
    ]; } |

    // LDI (HL), qq = LD (HL), q1, INC HL, LD (HL), q0, INC HL
    'ldi' __ '\(' _ 'hl' _ '\)' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0b01110000 | r_bits(qq[1]),
      0x23,
      0b01110000 | r_bits(qq[0]),
      0x23
    ]; } |

    // LDI (IX+d), qq = LD (IX+d), q1, INC IX, LD (IX+d), q0, INC IX
    'ldi' __ '\(' _ i=IX _ '\)' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0xDD, 0b01110000 | r_bits(qq[1]), index(i.offset),
      0xDD, 0x23,
      0xDD, 0b01110000 | r_bits(qq[0]), index(i.offset),
      0xDD, 0x23
    ]; } |

    // LDI (IY+d), qq = LD (IY+d), q1, INC IY, LD (IX+d), q0, INC IY
    'ldi' __ '\(' _ i=IY _ '\)' _ ',' _ qq=qq &eos
    .elements = AstElements { return [
      0xFD, 0b01110000 | r_bits(qq[1]), index(i.offset),
      0xFD, 0x23,
      0xFD, 0b01110000 | r_bits(qq[0]), index(i.offset),
      0xFD, 0x23
    ]; }

FakeLoadIncrement8Instruction :=
    // LDI A, (BC) = LD A, (BC), INC BC
    'ldi' __ 'a' _ ',' _ '\(' _ 'bc' _ '\)' &eos
    .elements = AstElements { return [0x0A, 0x03]; } |

    // LDI A, (DE) = LD A, (DE), INC DE
    'ldi' __ 'a' _ ',' _ '\(' _ 'de' _ '\)' &eos
    .elements = AstElements { return [0x1A, 0x13]; } |

    // LDI r, (HL) = LD r, (HL), INC HL
    'ldi' __ r=r _ ',' _ '\(' 'hl' '\)' &eos
    .elements = AstElements { return [0b01000110 | r_bits(r, 3), 0x23]; } |

    // LDI r, (IX+d) = LD r, (IX+d), INC IX
    'ldi' __ r=r _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0b01000110 | r_bits(r, 3), index(i.offset), 0xDD, 0x23]; } |

    // LDI r, (IY+d) = LD r, (IY+d), INC IY
    'ldi' __ r=r _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0b01000110 | r_bits(r, 3), index(i.offset), 0xFD, 0x23]; } |

    // LDI (BC), A = LD, (BC), A, INC BC
    'ldi' __ '\(' _ 'bc' _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0x02, 0x03]; } |

    // LDI (DE), A
    'ldi' __ '\(' _ 'de' _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0x12, 0x13]; } |

    // LDI (HL), r = LD (HL), r, INC HL
    'ldi' __ '\(' _ 'hl' _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0b01110000 | r_bits(r), 0x23]; } |

    // LDI (IX+d), r = LD (IX+d), INC IX
    'ldi' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0b01110000 | r_bits(r), index(i.offset), 0xDD, 0x23]; } |

    // LDI (IY+d), r = LD (IY+d), INC IY
    'ldi' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0b01110000 | r_bits(r), index(i.offset), 0xFD, 0x23]; } |

    // LDI (HL), n = LD (HL), n, INC HL
    'ldi' __ '\(' 'hl' '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0x36, value8(pos, n), 0x23]; } |

    // LDI (IX+d), n = LD (IX+d), INC IX
    'ldi' __ '\(' _ i=IX _ '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xDD, 0x36, index(i.offset), value8(pos, n), 0xDD, 0x23]; } |

    // LDI (IY+d), n = LD (IY+d), INC IY
    'ldi' __ '\(' _ i=IY _ '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xFD, 0x36, index(i.offset), value8(pos, n), 0xFD, 0x23]; }

FakeLoadDecrement8Instruction :=
    // LDD A, (BC) = LD A, (BC), DEC BC
    'ldd' __ 'a' _ ',' _ '\(' _ 'bc' _ '\)' &eos
    .elements = AstElements { return [0x0A, 0x0B]; } |

    // LDD A, (DE) = LD A, (DE), DEC DE
    'ldd' __ 'a' _ ',' _ '\(' _ 'de' _ '\)' &eos
    .elements = AstElements { return [0x1A, 0x1B]; } |

    // LDD r, (HL) = LD r, (HL), DEC HL
    'ldd' __ r=r _ ',' _ '\(' 'hl' '\)' &eos
    .elements = AstElements { return [0b01000110 | r_bits(r, 3), 0x2B]; } |

    // LDD r, (IX+d) = LD r, (IX+d), DEC IX
    'ldd' __ r=r _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0b01000110 | r_bits(r, 3), index(i.offset), 0xDD, 0x2B]; } |

    // LDD r, (IY+d) = LD r, (IY+d), DEC IY
    'ldd' __ r=r _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0b01000110 | r_bits(r, 3), index(i.offset), 0xFD, 0x2B]; } |

    // LDD (BC), A = LD, (BC), A, DEC BC
    'ldd' __ '\(' _ 'bc' _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0x02, 0x0B]; } |

    // LDD (DE), A = LD (DE), A, DEC DE
    'ldd' __ '\(' _ 'de' _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0x12, 0x1B]; } |

    // LDD (HL), r = LD (HL), r, DEC HL
    'ldd' __ '\(' _ 'hl' _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0b01110000 | r_bits(r), 0x2B]; } |

    // LDD (IX+d), r = LD (IX+d), DEC IX
    'ldd' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0b01110000 | r_bits(r), index(i.offset), 0xDD, 0x2B]; } |

    // LDD (IY+d), r = LD (IY+d), DEC IY
    'ldd' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0b01110000 | r_bits(r), index(i.offset), 0xFD, 0x2B]; } |

    // LDD (HL), n = LD (HL), n, DEC HL
    'ldd' __ '\(' 'hl' '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0x36, value8(pos, n), 0x2B]; } |

    // LDD (IX+d), n = LD (IX+d), DEC IX
    'ldd' __ '\(' _ i=IX _ '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xDD, 0x36, index(i.offset), value8(pos, n), 0xDD, 0x2B]; } |

    // LDD (IY+d), n = LD (IY+d), DEC IY
    'ldd' __ '\(' _ i=IY _ '\)' _ ',' _ pos=@ n=Expression &eos
    .elements = AstElements { return [0xFD, 0x36, index(i.offset), value8(pos, n), 0xFD, 0x2B]; }

// Rotate and Shift
RotateShiftInstruction :=
    // RLCA
    'rlca' &eos
    .elements = AstElements { return [0x07]; } |

    // RLA
    'rla' &eos
    .elements = AstElements { return [0x17]; } |

    // RRCA
    'rrca' &eos
    .elements = AstElements { return [0x0F]; } |

    // RRA
    'rra' &eos
    .elements = AstElements { return [0x1F]; } |

    // RLC r
    'rlc' __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00000000 | r_bits(r)]; } |

    // RLC (HL)
    'rlc' __ '\(' _ 'hl' _ '\)' &eos
    .elements = AstElements { return [0xCB, 0x06]; } |

    // RLC (IX+d)
    'rlc' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x06]; } |

    // RLC (IY+d)
    'rlc' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x06]; } |

    // RL r
    'rl' __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00010000 | r_bits(r)]; } |

    // RL (HL)
    'rl' __ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0x16]; } |

    // RL (IX+d)
    'rl' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x16]; } |

    // Undocumented RL (IX+d), r
    'rl' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x10 + r_bits(r)]; } |

    // RL (IY+d)
    'rl' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x16]; } |

    // Undocumented RL (IY+d), r
    'rl' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x10 + r_bits(r)]; } |

    // RRC r
    'rrc' __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00001000 | r_bits(r)]; } |

    // RRC (HL)
    'rrc' __ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0x0E]; } |

    // RRC (IX+d)
    'rrc' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x0E]; } |

    // Undocumented RRC (IX+d), r
    'rrc' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x08 + r_bits(r)]; } |

    // RRC (IY+d)
    'rrc' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x0E]; } |

    // Undocumented RRC (IY+d), r
    'rrc' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x08 + r_bits(r)]; } |

    // RR r
    'rr' __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00011000 | r_bits(r)]; } |

    // RR (HL)
    'rr' __ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0x1E]; } |

    // RR (IX+d)
    'rr' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x1E]; } |

    // Undocumented RR (IX+d), r
    'rr' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x18 + r_bits(r)]; } |

    // RR (IY+d)
    'rr' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x1E]; } |

    // Undocumented RR (IY+d), r
    'rr' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x18 + r_bits(r)]; } |

    // SLA r
    'sla' __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00100000 | r_bits(r)]; } |

    // SLA (HL)
    'sla' __ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0x26]; } |

    // SLA (IX+d)
    'sla' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x26]; } |

    // Undocumented SLA (IX+d), r
    'sla' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x20 + r_bits(r)]; } |

    // SLA (IY+d)
    'sla' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x26]; } |

    // Undocumented SLA (IY+d), r
    'sla' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x20 + r_bits(r)]; } |

    // Undocumented SLL r
    {'sll' | 'sli'} __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00110000 | r_bits(r)]; } |

    // Undocumented SLL (HL)
    {'sll' | 'sli'} __ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0x36]; } |

    // Undocumented SLL (IX+d)
    {'sll' | 'sli'} __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x36]; } |

    // Undocumented SLL (IX+d), r
    {'sll' | 'sli'} __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x30 + r_bits(r)]; } |

    // Undocumented SLL (IY+d)
    {'sll' | 'sli'} __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x36]; } |

    // Undocumented SLL (IY+d), r
    {'sll' | 'sli'} __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x30 + r_bits(r)]; } |

    // SRA r
    'sra' __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00101000 | r_bits(r)]; } |

    // SRA (HL)
    'sra' __ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0x2E]; } |

    // SRA (IX+d)
    'sra' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x2E]; } |

    // Undocumented SRA (IX+d), r
    'sra' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x28 + r_bits(r)]; } |

    // SRA (IY+d)
    'sra' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x2E]; } |

    // Undocumented SRA (IY+d), r
    'sra' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x28 + r_bits(r)]; } |

    // SRL r
    'srl' __ r=r &eos
    .elements = AstElements { return [0xCB, 0b00111000 | r_bits(r)]; } |

    // SRL (HL)
    'srl' __ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0x3E]; } |

    // SRL (IX+d)
    'srl' __ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x3E]; } |

    // Undocumented SRL (IX+d), r
    'srl' __ '\(' _ i=IX _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0x38 + r_bits(r)]; } |

    // SRL (IY+d)
    'srl' __ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x3E]; } |

    // Undocumented SRL (IY+d), r
    'srl' __ '\(' _ i=IY _ '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0x38 + r_bits(r)]; } |

    // RLD
    'rld' &eos
    .elements = AstElements { return [0xED, 0x6F]; } |

    // RRD
    'rrd' &eos
    .elements = AstElements { return [0xED, 0x67]; }

// Fake 16-bit rotate and shift
FakeRotateShiftInstruction16 :=
    // RL qq = RL r, RL r
    'rl' __ qq=qq &eos
    .elements = AstElements { return [
      0xCB, 0b00010000 | r_bits(qq[0]),
      0xCB, 0b00010000 | r_bits(qq[1])
    ]; } |

    // RR qq
    'rr' __ qq=qq &eos
    .elements = AstElements { return [
      0xCB, 0b00011000 | r_bits(qq[0]),
      0xCB, 0b00011000 | r_bits(qq[1])
    ]; } |

    // SLA
    'sla' __ qq=qq &eos
    .elements = AstElements { return [
      0xCB, 0b00100000 | r_bits(qq[0]),
      0xCB, 0b00100000 | r_bits(qq[1])
    ]; } |

    // SLL
    {'sll' | 'sli'} __ qq=qq &eos
    .elements = AstElements { return [
      0xCB, 0b00110000 | r_bits(qq[0]),
      0xCB, 0b00110000 | r_bits(qq[1])
    ]; } |

    // SRA
    'sra' __ qq=qq &eos
    .elements = AstElements { return [
      0xCB, 0b00101000 | r_bits(qq[0]),
      0xCB, 0b00101000 | r_bits(qq[1])
    ]; } |

    // SRL
    'srl' __ qq=qq &eos
    .elements = AstElements { return [
      0xCB, 0b00111000 | r_bits(qq[0]),
      0xCB, 0b00111000 | r_bits(qq[1])
    ]; }

// Bit Manipulation
BitManipulationInstruction :=
    // BIT b, r
    'bit' __ b=b _ ',' _ r=r &eos
    .elements = AstElements { return [0xCB, 0b01000000 | (b.value << 3) | r_bits(r)]; } |

    // BIT b, (HL)
    'bit' __ b=b _ ',' _ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0b01000110 | (b.value << 3)]; } |

    // BIT b, (IX+d)
    'bit' __ b=b _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0b01000110 | (b.value << 3)]; } |

    // BIT b, (IY+d)
    'bit' __ b=b _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0b01000110 | (b.value << 3)]; } |

    // SET b, r
    'set' __ b=b _ ',' _ r=r &eos
    .elements = AstElements { return [0xCB, 0b11000000 | (b.value << 3) | r_bits(r)]; } |

    // SET b, (HL)
    'set' __ b=b _ ',' _ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0b11000110 | (b.value << 3)]; } |

    // SET b, (IX+d)
    'set' __ b=b _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0b11000110 | (b.value << 3)]; } |

    // SET b, (IY+d)
    'set' __ b=b _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0b11000110 | (b.value << 3)]; } |

    // RES b, r
    'res' __ b=b _ ',' _ r=r &eos
    .elements = AstElements { return [0xCB, 0b10000000 | (b.value << 3) | r_bits(r)]; } |

    // RES b, (HL)
    'res' __ b=b _ ',' _ '\(hl\)' &eos
    .elements = AstElements { return [0xCB, 0b10000110 | (b.value << 3)]; } |

    // RES b, (IX+d)
    'res' __ b=b _ ',' _ '\(' _ i=IX _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xCB, index(i.offset), 0b10000110 | (b.value << 3)]; } |

    // RES b, (IY+d)
    'res' __ b=b _ ',' _ '\(' _ i=IY _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xCB, index(i.offset), 0b10000110 | (b.value << 3)]; }

Offset :=
    pos=@ label=Label
    .eval = EvalFunc { return labelValue(pos, label.name); } |

    e=Expression
    .eval = EvalFunc { return e.eval; }

// Jumps
JumpInstruction :=
    // JP (HL)
    'jp' __ '\(hl\)' &eos
    .elements = AstElements { return [0xE9]; } |

    // JP (IX)
    'jp' __ '\(' _ 'ix' _ '\)' &eos
    .elements = AstElements { return [0xDD, 0xE9]; } |

    // JP (IY)
    'jp' __ '\(' _ 'iy' _ '\)' &eos
    .elements = AstElements { return [0xFD, 0xE9]; } |

    // JP nn
    'jp' __ pos=@ ee=Expression &eos
    .elements = AstElements { return [0xC3, value16LE(pos, ee)]; } |

    // JP CC, nn
    'jp' __ cc=cc _ ',' _ pos=@ ee=Expression &eos
    .elements = AstElements { return [0b11000010 | cc_bits(cc, 3), value16LE(pos, ee)]; } |

    // JR label
    'jr' __ pos=@ label=Label &eos
    .elements = AstElements { return [jj_bits(), jrRelativeOffset(pos, label.name)]; } |

    // JR e
    'jr' __ pos=@ e=Expression &eos
    .elements = AstElements { return [jj_bits(), jrOffset(pos, e)]; } |

    // JR jj, label
    'jr' __ jj=jj _ ',' _ pos=@ label=Label &eos
    .elements = AstElements { return [jj_bits(jj), jrRelativeOffset(pos, label.name)]; } |

    // JR jj, e
    'jr' __ jj=jj _ ',' _ pos=@ e=Expression &eos
    .elements = AstElements { return [jj_bits(jj), jrOffset(pos, e)]; } |

    // DJNZ label
    'djnz' __ pos=@ label=Label &eos
    .elements = AstElements { return [0x10, jrRelativeOffset(pos, label.name)]; } |

    // DJNZ e
    'djnz' __ pos=@ e=Expression &eos
    .elements = AstElements { return [0x10, jrOffset(pos, e)]; }

// Calls
CallInstruction :=
    // CALL nn
    'call' __ pos=@ ee=Expression &eos
    .elements = AstElements { return [0xCD, value16LE(pos, ee)]; } |

    // CALL cc, nn
    'call' __ cc=cc _ ',' _ pos=@ ee=Expression &eos
    .elements = AstElements { return [0b11000100 | cc_bits(cc, 3), value16LE(pos, ee)]; }

// Returns
ReturnInstruction :=
    // RET
    'ret' &eos
    .elements = AstElements { return [0xC9]; } |

    // RET cc
    'ret' __ cc=cc &eos
    .elements = AstElements { return [0b11000000 | cc_bits(cc, 3)]; } |

    // RETI
    'reti' &eos
    .elements = AstElements { return [0xED, 0x4D]; } |

    // RETN
    'retn' &eos
    .elements = AstElements { return [0xED, 0x45]; } |

    // RST p
    'rst' __ p=p &eos
    .elements = AstElements { return [0b11000111 | p_bits(p.value, 3)]; }

// Inputs
InputInstruction :=
    // Have to be before IN A, (n)
    // IN r, (C)
    'in' __ r=r _ ',' _ '\(' 'c' '\)' &eos
    .elements = AstElements { return [0xED, 0b01000000 | r_bits(r, 3)]; } |

    // IN A, (n)
    'in' __ 'a' _ ',' _ '\(' _ pos=@ n=Expression _ '\)' &eos
    .elements = AstElements { return [0xDB, value8(pos, n)]; } |

    // Undocumented IN F, (C)
    'in' __ 'f' _ ',' _ '\(' 'c' '\)' &eos
    .elements = AstElements { return [0xED, 0x70]; } |

    // INI
    'ini' &eos
    .elements = AstElements { return [0xED, 0xA2]; } |

    // INIR
    'inir' &eos
    .elements = AstElements { return [0xED, 0xB2]; } |

    // IND
    'ind' &eos
    .elements = AstElements { return [0xED, 0xAA]; } |

    // INDR
    'indr' &eos
    .elements = AstElements { return [0xED, 0xBA]; }

// Outputs
OutputInstruction :=
    // Have to be before OUT (n), A
    // Undocumented OUT (C), 0
    'out' __ '\(' 'c' '\)' _ ',' _ '0' &eos
    .elements = AstElements { return [0xED, 0x71]; } |

    // Have to be before OUT (n), A
    // OUT (C), r
    'out' __ '\(' 'c' '\)' _ ',' _ r=r &eos
    .elements = AstElements { return [0xED, 0b01000001 | r_bits(r, 3)]; } |

    // OUT (n), A
    'out' __ '\(' _ pos=@ n=Expression _ '\)' _ ',' _ 'a' &eos
    .elements = AstElements { return [0xD3, value8(pos, n)]; } |

    // OUTI
    'outi' &eos
    .elements = AstElements { return [0xED, 0xA3]; } |

    // OTIR
    'otir' &eos
    .elements = AstElements { return [0xED, 0xB3]; } |

    // OUTD
    'outd' &eos
    .elements = AstElements { return [0xED, 0xAB]; } |

    // OTDR
    'otdr' &eos
    .elements = AstElements { return [0xED, 0xBB]; }

// Byte directive
ByteDirective :=
    'db' | 'dm' | '\.?byte' | 'defb' | 'defm'

// Word directive
WordDirective :=
    'dw' | '\.?word' | 'defw'

// Block directive
BlockDirective :=
    '\.?block' | 'defs' | 'ds'

// A Byte directive contains either characters, strings, or expressions
ByteValue :=
    s=QuottedStr        .elements = AstElements { return s.elements; } |
    s=DoubleQuottedStr  .elements = AstElements { return s.elements; } |
    pos=@ e=Expression  .elements = AstElements { return [value8(pos, e)]; }

// A Word directive contains expressions
WordValue :=
    pos=@ e=Expression  .elements = AstElements { return [value16LE(pos, e)]; }

// A Data directive is either a Byte directive, a Word directive or a Block directive
DataDirective :=
    // byte $FF, ...
    ByteDirective __ pos0=@ data0=ByteValue data={_ ',' _ inner=ByteValue}* &eos
    .elements = AstElements { return dataBytes(pos0, data0, data); } |

    // word $FFFF, ...
    WordDirective __ pos0=@ data0=WordValue data={_ ',' _ inner=WordValue}* &eos
    .elements = AstElements { return dataWords(pos0, data0, data); } |

    // block length, fill byte
    BlockDirective __ @pos0=@ nn=Expression data={_ ',' _ pos1=@ b=Expression}? &eos
    .elements = AstElements { return [dataBlock(pos0, nn, data?.pos1, data?.b)]; }

// An escape sequence is either simple, in octal or in hexadecimal
EscapeSequence :=
    SimpleEscapeSequence |
    OctalEscapeSequence |
    HexadecimalEscapeSequence

// A simple escape is a backslash followed by a character
SimpleEscapeSequence :=
    pos=@ '\\' raw={'"' | 'n'}
    .elements = AstElements { return parseSimpleEscape(pos, raw); }

// An octal escape is a backslash followed by an octal value
OctalEscapeSequence :=
    '\\' pos=@ raw='[0-7]{1,3}'
    .elements = AstElements { return parseOctalEscape(pos, raw); }

// An hexadecimal escape is a backslash followed by an 'x' and an hexadecimal value
HexadecimalEscapeSequence :=
    '\\x' pos=@ raw='[0-9a-f]{1,2}'
    .elements = AstElements { return parseHexadecimalEscape(pos, raw); }

// A character that is not a quote, a backslash or a newline
NoQuoteChar :=
    pos=@ raw='[^\'\\\n]'
    .elements = AstElements { return parseChar(pos, raw); }

// A character is not a double-quote, a backslash or a newline
NoDoubleQuoteChar :=
    pos=@ raw='[^\"\\\n]'
    .elements = AstElements { return parseChar(pos, raw); }

// A string literal enclosed in double-quotes and containing either simple characters or escape sequences
QuottedStr :=
    '\'' pos=@ chars={NoQuoteChar | EscapeSequence}+ '\''
    .elements = AstElements { return chars.reduce((r, c) => { return r.concat(c.elements); }, [] as AstElements); }

// A string literal is enclosed in double-quotes and contains either simple characters or escape sequences
DoubleQuottedStr :=
    '\"' pos=@ chars={NoDoubleQuoteChar | EscapeSequence}+ '\"'
    .elements = AstElements { return chars.reduce((r, c) => { return r.concat(c.elements); }, [] as AstElements); }


// A comment starts with '//' or ';' and goes until the end of the statement
Comment :=
    '(//|;)[^\r\n]*'

// An Origin directive is 'org' (or an alias) followed by a 16-bit value and the end of the statement
OriginDirective :=
    '\.?org' __ address=nn

// A filename is optionally enclosed in double-quotes and contains a subset of characters.
Filename :=
    '"' raw='[^"\\:\*\?<>\|%#\$,]+' '"' |
    raw='[^ \t\r\n"\\:\*\?<>\|%#\$,]+'

// An Include directive starts with 'include' (or an alias) and is followed by a Filename
IncludeDirective :=
    pos=@ '\.?include' __ name=Filename &eos
    .info = LinesInfo { return includeFile(pos, name.raw); }

// An Output directive starts with 'output' (or an alias) and is followed by a Filename.
// Optionally, it is followed by a comma, 'sld' and an filename
OutputDirective :=
    '\.?output' __ name=Filename sld={_ ',' _ 'sld' __ name=Filename}? &eos
    .void = void { setOutputName(name.raw, sld?.name.raw); }

// A Device directive starts with 'device' (or an alias) and is followed by a name (the target)
DeviceDirective :=
    '\.?device' __ pos=@ raw='[a-zA-Z][0-9a-zA-Z]*' &eos
    .void = void { setDevice(pos, raw); }

// A End directive will stop the parsing by eating all the characters
EndDirective :=
  '\.?end' &eos '.*'
