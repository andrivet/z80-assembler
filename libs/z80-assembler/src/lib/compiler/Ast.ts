/**
 * Z80 Assembler in Typescript
 *
 * File:        Ast.ts
 * Description: Types for building the Abstract Syntax Tree
 * Author:			Sebastien Andrivet
 * License:			GPLv3
 * Copyrights: 	Copyright (C) 2023 Sebastien Andrivet
 */
import {byte, bytes} from '../types/Types';
import {CompilationError} from "../types/Error";
import {ByteValue, Expression, PosInfo, WordValue} from "../grammar/z80";
import {getLabelValue} from "./Labels";
import {parseData} from "../compiler/Compiler";

/**
 * A function taking no argument and returning a number (if it is known) or null (if it is unknown)
 */
export type EvalFunc = () => number | null;

/**
 * An abstract element generated by the parser
 */
export interface AstBase {
  // The number of bytes that will be generated by this element
  get size(): number;
  // Generate actual bytes
  generate(instructionAddress: number): bytes;
}

/**
 * An AST element that represents a block of bytes.
 */
class ByteBlock implements AstBase {
  private readonly filename = parseData.fileName;

  constructor(
    private pos0: PosInfo,
    private length: Expression,
    private pos1: PosInfo | undefined,
    private value: Expression | undefined) { }

  get size(): number {
    const size = this.length.eval();
    if(size == null) throw new CompilationError(this.filename, this.pos0, "Unknown size for the data block");
    if(size < 0) throw new CompilationError(this.filename, this.pos0, `Invalid size size for the data block: ${size}`);
    return size;
  }

  private getValue() {
    if(this.value == null || this.pos1 == null) return 0;
    let v =  this.value.eval();
    if(v == null) throw new CompilationError(this.filename, this.pos1, `Not able to determine a value`);
    if(v < -256 || v > 255) throw new CompilationError(this.filename, this.pos1, `Invalid 8-bits value: ${v}`);
    if(v < 0) v = 256 + v;
    return v;
  }

  generate(/*_: number*/): bytes {
    const array = new Array<byte>(this.size);
    array.fill(this.getValue());
    return array;
  }
}

/**
 * An AST element that represents a 16-byte value.
 */
class Byte16 implements AstBase {
  private readonly filename = parseData.fileName;
  constructor(private pos: PosInfo, private expression: Expression) { }
  get size(): number { return 2; }
  generate(/*_: number*/): bytes {
    let v = this.expression.eval();
    if(v == null) throw new CompilationError(this.filename, this.pos, `Not able to determine the 16-bits value`);
    if(v < -65536 || v > 65535) throw new CompilationError(this.filename, this.pos, `Invalid 16-bits value: ${v}`);
    if(v < 0) v = 65536 + v;
    return [v & 0x00FF, (v & 0xFF00) >> 8];
  }
}

/**
 * An AST  element that represents a 8-byte value.
 */
class Byte8 implements AstBase {
  private readonly filename = parseData.fileName;
  constructor(private pos: PosInfo, private expression: Expression) {}
  get size(): number { return 1; }
  generate(/*_: number*/): bytes {
    let v = this.expression.eval();
    if(v == null) throw new CompilationError(this.filename, this.pos, `Not able to determine the 8-bits value`);
    if(v < -256 || v > 255) throw new CompilationError(this.filename, this.pos, `Invalid 8-bits value: ${v}`);
    if(v < 0) v = 256 + v;
    return [v];
  }
}

/**
 * An AST element that represents a negative 8-byte value.
 */
class ByteNeg8 implements AstBase {
  private readonly filename = parseData.fileName;
  constructor(private pos: PosInfo, private expression: Expression) {}
  get size(): number { return 1; }
  generate(/*_: number*/): bytes {
    let v = this.expression.eval();
    if(v == null) throw new CompilationError(this.filename, this.pos, `Not able to determine the 8-bits value`);
    v = -v;
    if(v < -256 || v > 255) throw new CompilationError(this.filename, this.pos, `Invalid 8-bits value: ${v}`);
    if(v < 0) v = 256 + v;
    return [v];
  }
}

/**
 * An AST element that represents a relative jump.
 */
class Jr implements AstBase {
  private readonly filename = parseData.fileName;
  constructor(private pos: PosInfo, private expression: Expression) {}
  get size(): number { return 1; }
  generate(/*_: number*/): bytes {
    let offset = this.expression.eval();
    if(offset == null) throw new CompilationError(this.filename, this.pos, `Not able to determine the offset value`);
    if(offset < -126 || offset > 129) throw new CompilationError(this.filename, this.pos,`Invalid offset for JR instruction: ${offset}`);
    offset -= 2;
    if(offset < 0) offset = 256 + offset;
    return [offset];
  }
}

/**
 * An AST element that represents a relative jump with a relative offset.
 */
class JrRelative implements AstBase {
  private readonly filename = parseData.fileName;
  constructor(private pos: PosInfo, private label: string) {}
  get size(): number { return 1; }
  generate(instructionAddress: number): bytes {
    const targetAddress = getLabelValue(this.label);
    if(targetAddress == null) throw new CompilationError(this.filename, this.pos, `Not able to determine the value of label '${this.label}'`);
    let offset = targetAddress - instructionAddress;
    if(offset < -126 || offset > 129) throw new CompilationError(this.filename, this.pos,`Label ${this.label} is to far from JR instruction: ${offset} bytes`);
    offset -= 2;
    if(offset < 0) offset = 256 + offset;
    return [offset];
  }
}

/**
 * An AST element is either a number (the raw byte value) or derived from AstBase
 */
export type AstElement = number | AstBase;

/**
 * Array of AST elements
 */
export type AstElements = AstElement[];

/**
 * Determine if an AST element is a raw byte or derived from AstBase (i.e. abstract)
 * @param element The element to test.
 * @return true if the element is concrete (a raw byte value), false if it is abstract.
 */
export function isAbstract(element: AstElement): element is AstBase {
  return (element as AstBase).generate !== undefined;
}

/**
 * Determine the actual size in byte of an AST element.
 * @param element The AST element.
 * @return The number of bytes that will be generated by this element
 */
export function getByteSize(element: AstElement): number {
  return isAbstract(element) ? element.size : 1;
}

/**
 * Get the low part of a 16-bit little endian value.
 * @param value A 16-bit little endian value.
 */
export function low(value: number) {
  return value & 0x00FF;
}

/**
 * Get the high part of a 16-bit little endian value.
 * @param value A 16-bit little endian value.
 */
export function high(value: number) {
  return (value & 0xFF00) >> 8;
}

/**
 * An Evaluable interface, i.e. that contains an eval function that returns a number or null.
 */
interface Evaluable { eval: EvalFunc; }

/**
 * An Inner Expression i.e. that extends an Evaluable interface.
 */
interface InnerExpression<E extends Evaluable> { e: E; }

/**
 * A Binary operation interface, i.e. a function with two arguments and that returns a number.
 */
type BinaryOperation = (a: number, b: number) => number

/**
 * A Unary operation interface, i.e. a function with one argument and that returns a number.
 */
type UnaryOperation = (a: number) => number

/**
 * A Binary function such as: 2 * 4 * 2.
 * @param left Left side of the binary function (an array of operands).
 * @param right Right side of the binary function.
 * @param op Operation to be applied to the left and right side.
 */
export function binaryOperation<
  Operation extends BinaryOperation,
  Inner extends Evaluable,
  Left extends InnerExpression<Inner>,
  Right extends Evaluable>(left: Left[], right: Right, op: Operation): EvalFunc {
  return () => {
    // Evaluate the right side
    const rightValue = right.eval();
    // If the right value is null, the result is null
    if(rightValue == null) return null;
    // If the left side is empty, we return the right side
    if(left.length <= 0) return rightValue;
    // Evaluate the leftmost argument
    const leftmostValue = left[0].e.eval();
    // Evaluate the other arguments on the left
    const partial = left.slice(1).reduce((r: number | null, c: Left) => {
      // Evaluate the current value
      const currentValue = c.e.eval();
      // If a value is null, the whole result is null. Otherwise, apply the operation to the arguments
      return (r == null || currentValue == null) ? null : op(r, currentValue);
    }, leftmostValue);
    // If a value is null, the whole result is null. Otherwise, apply the operation to the arguments
    return partial == null ? null : op(partial, rightValue);
  }
}

/**
 * A map of strings versus binary operations. For example: '*' => operatorMul
 */
type BinaryOperationsMap = { [key: string]: BinaryOperation };

/**
 * A map of strings versus unary operations. For example: '-' => operatorNeg
 */
type UnaryOperationsMap = { [key: string]: UnaryOperation };

/**
 * An Inner Operator i.e. that extends an Inner Expression, itself extending an Evaluable.
 */
interface InnerOp<E extends Evaluable> extends InnerExpression<E>{ op: string; }

/**
 * A Binary function such as: 2 * 4 * 2.
 * @param left Left side of the binary function (an array of operands).
 * @param right Right side of the binary function.
 * @param map Map the operations to be applied to the left and right side.
 */
export function binaryOperations<
  Inner extends Evaluable,
  Left extends InnerOp<Inner>,
  Right extends Evaluable>(left: Left[], right: Right, map: BinaryOperationsMap): EvalFunc {
  return () => {
    // Evaluate the right side
    const rightValue = right.eval();
    // If the right value is null, the result is null
    if(rightValue == null) return null;
    // If the left side is empty, we return the right side
    if(left.length <= 0) return rightValue;
    // Evaluate the leftmost argument
    const leftmost = left[0];
    // Evaluate the other arguments on the left
    const partial = left.slice(1).reduce((r: number | null, c: Left) => {
      // Evaluate the current value
      const currentValue = c.e.eval();
      // If a value is null, the whole result is null. Otherwise, apply the operation to the arguments
      return (r == null || currentValue == null) ? null : map[c.op](r, currentValue);
    }, leftmost.e.eval());
    // If a value is null, the whole result is null. Otherwise, apply the operation to the arguments
    return partial == null ? null : map[leftmost.op](partial, rightValue);
  }
}

/**
 * A Unary operation.
 * @param e The argument.
 * @param op The operation to be applied to the argument.
 */
export function unaryOperation<
  Operation extends UnaryOperation,
  E extends Evaluable>(e: E, op: Operation): EvalFunc {
  // Evaluate the argument. If the value is null, the result is null. Otherwise, apply the operation.
  return () => { const value = e.eval(); return (value == null) ? null : op(value); }
}

/**
 * A Unary operation.
 * @param e The argument.
 * @param op The operation to be applied to the argument as a string.
 * @param map Map the operations to be applied to the argument.
 */
export function unaryOperations<
  E extends Evaluable>(e: E, op: string, map: UnaryOperationsMap): EvalFunc {
  return () => { const value = e.eval(); return (value == null) ? null : map[op](value); }
}

// Note: As far as I know, it is not possible to manipulate in Javascript and Typescript builtin operators.
// So we define a set of functions for this purpose.

export const operatorOr = (a: number, b: number) => a | b;
export const operatorXor = (a: number, b: number) => a ^ b;
export const operatorAnd = (a: number, b: number) => a & b;
export const operatorLeftShift = (a: number, b: number) => a << b;
export const operatorRightShift = (a: number, b: number) => a >> b;
export const operatorAdd = (a: number, b: number) => a + b;
export const operatorSub = (a: number, b: number) => a - b;
export const operatorMul = (a: number, b: number) => a * b;
export const operatorDiv = (a: number, b: number) => Math.trunc(a / b);
export const operatorModulo = (a: number, b: number) => a % b;
export const operatorPlus = (a: number) => +a;
export const operatorNeg = (a: number) => -a;
export const operatorInvert = (a: number) => ~a;
export const operatorIdentity = (a: number) => a;

/**
 * Returns an AST element that represents the low part of a little-endian 16-bit value.
 * @param pos The position of the element in the source.
 * @param e The little-endian 16-bit value
 */
export function value16LE(pos: PosInfo, e: Expression): AstElement {
  return new Byte16(pos, e);
}

/**
 * Returns an AST element that represents an 8-bit unsigned value.
 * @param pos The position of the element in the source.
 * @param e The 8-bit unsigned value
 */
export function value8(pos: PosInfo, e: Expression): AstElement {
  return new Byte8(pos, e);
}

/**
 * Returns an AST element that represents an 8-bit signed value.
 * @param pos The position of the element in the source.
 * @param s The sign of the value.
 * @param e The 8-bit signed value
 */
export function svalue8(pos: PosInfo, s: string, e: Expression): AstElement {
  return s === '-' ? new ByteNeg8(pos, e) : new Byte8(pos, e);
}

/**
 * Returns an AST element that represents an offset for a JR (jump relative) opcode.
 * @param pos The position of the element in the source.
 * @param e The offset value
 */
export function jrOffset(pos: PosInfo, e: Expression): AstElement {
  return new Jr(pos, e);
}

/**
 * Returns an AST element that represents an offset for a JR (jump relative) opcode.
 * @param pos The position of the element in the source.
 * @param label The label that will give the offset value
 */
export function jrRelativeOffset(pos: PosInfo, label: string): AstElement {
  return new JrRelative(pos, label);
}

/**
 * An Inner Byte, i.e. it contains an inner field that is a Byte value.
 */
export interface InnerByte { inner: ByteValue }

/**
 * An Inner Word, i.e. it contains an inner field that is a Word value.
 */
export interface InnerWord { inner: WordValue }

/**
 * The bytes of a Byte directive
 * @param _ The position of the bytes in the source code.
 * @param data0 The first byte.
 * @param data The other bytes.
 */
export function dataBytes(_: PosInfo, data0: ByteValue, data: InnerByte[]): AstElements {
  return data.reduce((r, c) => r.concat(c.inner.elements), data0.elements);
}

/**
 * The words of a Word directive
 * @param _ The position of the words in the source code.
 * @param data0 The first word.
 * @param data The other words.
 */
export function dataWords(_: PosInfo, data0: WordValue, data: InnerWord[]): AstElements {
  return data.reduce((r, c) => r.concat(c.inner.elements), data0.elements);
}

/**
 * The parameters of a block of data.
 * @param pos0 The position of the length in the source code.
 * @param length The length (in bytes) of the block
 * @param pos1 The position of the value in the source code.
 * @param value The value used to initialize the block.
 */
export function dataBlock(pos0: PosInfo, length: Expression, pos1: PosInfo | undefined, value: Expression | undefined): AstElement {
  return new ByteBlock(pos0, length, pos1, value);
}
